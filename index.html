<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>3D carousel</title>

    <!-- Babylon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

    <script src="babylon.js"></script>
    <script src="babylon.glTFFileLoader.js"></script>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>

<body>
    <button class="btn btn-primary" id="turnRight">Turn</button>
    <div style="width:1200px; height:300px;">
        <canvas id="renderCanvas"></canvas>
        <script>
            var canvas = document.getElementById("renderCanvas");

            var startRenderLoop = function (engine, canvas) {
                engine.runRenderLoop(function () {
                    if (sceneToRender && sceneToRender.activeCamera) {
                        sceneToRender.render();
                    }
                });
            }

            var engine = null;
            var scene = null;
            var sceneToRender = null;
            var createDefaultEngine = function () { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false }); };
            var createScene = function () {
                // This creates a basic Babylon Scene object (non-mesh)
                var scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color3(1, 1, 1)
                var camera = new BABYLON.ArcRotateCamera("camera", BABYLON.Tools.ToRadians(0), BABYLON.Tools.ToRadians(85), 6, BABYLON.Vector3.Zero(), scene);

                // This attaches the camera to the canvas
                camera.attachControl(canvas, true);

                // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
                var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

                // Default intensity is 1. Let's dim the light a small amount
                light.intensity = 0.7;

                // Our built-in 'ground' shape.
                // var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 6, height: 6 }, scene);

                /*
                BABYLON.SceneLoader.ImportMesh(
                    undefined,
                    "/../Models/snow-3d-model/",
                    "snow.gltf",
                    scene,
                    function (
                        meshes
                    ) {
                        scene.createDefaultCameraOrLight(true);
                        scene.activeCamera.attachControl(canvas, false);
                    }
                );
                */

                let r = 4.0;
                let pi = Math.PI;
                let numberOfModels = 15;
                // let separationAngle = 2 * pi / numberOfModels;
                for (let i = 0; i < numberOfModels; i++) {
                    let rotationAngle = (2 * pi * i) / numberOfModels;
                    let x = r * Math.cos(rotationAngle);
                    let z = r * Math.sin(rotationAngle);

                    BABYLON.SceneLoader.ImportMesh("", Assets.meshes.Yeti.rootUrl, Assets.meshes.Yeti.filename, scene, function (newMeshes) {
                        if (i == 0) {
                            newMeshes[0].scaling = new BABYLON.Vector3(0.02, 0.02, 0.02);
                        } else {
                            newMeshes[0].scaling = new BABYLON.Vector3(0.02, 0.02, 0.02);
                        }

                        newMeshes[0].rotate(BABYLON.Axis.Y, 3 * pi / 2 - rotationAngle, BABYLON.Space.LOCAL);
                        newMeshes[0].rotate(BABYLON.Axis.X, 0, BABYLON.Space.LOCAL);
                        newMeshes[0].rotate(BABYLON.Axis.Z, 0, BABYLON.Space.LOCAL);

                        newMeshes[0].position.x = x;
                        newMeshes[0].position.z = z;
                    });
                }

                BABYLON.SceneLoader.ImportMesh("myMesh1", "./Models/", "ProX_Platinum.gbl", scene, function (meshes) {
                    // do something with the meshes and skeletons
                    // particleSystems are always null for glTF assets
                });

                var animCamPosition = new BABYLON.Animation("animCam", "alpha", 10, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

                var keysPosition = [];
                keysPosition.push({
                    frame: 0,
                    value: 0
                });

                keysPosition.push({
                    frame: 30,
                    value: (2 * pi) / numberOfModels
                });


                animCamPosition.setKeys(keysPosition);

                camera.animations.push(animCamPosition);


                let myAnim = scene.beginAnimation(camera, 0, 100, true);
                setTimeout(() => { myAnim.pause() }, 0);

                // setTimeout(() => { myAnim.restart() }, 8000);

                return [myAnim, scene];
            };


            let startAnimation = function (scene, myAnim) {
                // let myAnim = scene.beginAnimation(camera, 0, 100, true);
                setTimeout(() => { myAnim.restart() }, 0);
                setTimeout(() => { myAnim.pause() }, 3000);
            };

            window.initFunction = async function () {

                var asyncEngineCreation = async function () {
                    try {
                        return createDefaultEngine();
                    } catch (e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                    }
                }


                window.engine = await asyncEngineCreation();
                if (!engine) throw 'engine should not be null.';
                startRenderLoop(engine, canvas);


                let [camera, scene] = createScene();
                document.getElementById('turnRight').addEventListener('click', () => { startAnimation(scene, camera) });
                window.scene = scene;

            };

            // document.getElementById('turnRight').addEventListener('click', startAnimation(window.scene));

            initFunction().then(() => {
                sceneToRender = scene
            });

            // Resize
            window.addEventListener("resize", function () {
                engine.resize();
            });
        </script>
    </div>


</body>

</html>